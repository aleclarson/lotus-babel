// Generated by CoffeeScript 1.12.4
var AsyncTaskGroup, babelCache, babelKeys, emptyFunction, fs, makeIgnoreFn, mergeDefaults, mm, objectify, path, resolvePath, steal, transformFile;

resolvePath = require("resolve").resolvePath;

AsyncTaskGroup = require("AsyncTaskGroup");

emptyFunction = require("emptyFunction");

mergeDefaults = require("mergeDefaults");

objectify = require("objectify");

steal = require("steal");

path = require("path");

mm = require("micromatch");

fs = require("fsx");

babelKeys = ["presets", "plugins", "only", "ignore", "sourceMaps", "babelrc", "extends"];

babelCache = Object.create(null);

module.exports = function(files, options) {
  var failed, ignore, tasks;
  if (options == null) {
    options = {};
  }
  tasks = AsyncTaskGroup({
    maxConcurrent: 3
  });
  failed = [];
  ignore = makeIgnoreFn(options);
  return tasks.map(files, function(file) {
    if (ignore(file.path)) {
      return;
    }
    return transformFile(file, options).fail(function(error) {
      failed.push({
        file: file,
        error: error
      });
      return null;
    });
  }).then(function(results) {
    if (failed.length && !options.quiet) {
      failed.forEach(function(arg) {
        var error, file, red;
        file = arg.file, error = arg.error;
        red = log.color.red;
        log.moat(1);
        log.white("Failed to compile:\n  " + (red(lotus.relative(file.path))));
        log.moat(1);
        log.gray.dim(error.codeFrame || error.stack);
        return log.moat(1);
      });
    }
    return results;
  });
};

transformFile = function(file, options) {
  var babel, babelOptions, babelPath, babelTransform, green, lastModified;
  if (!file.dest) {
    throw Error("File must have 'dest' defined before compiling: '" + file.path + "'");
  }
  lastModified = new Date;
  babelPath = resolvePath("babel-core", {
    parent: path.dirname(file.path)
  });
  if (!babelPath) {
    throw Error("Could not resolve 'babel-core' from '" + file.path + "'!");
  }
  if (!(babel = babelCache[babelPath])) {
    if (!options.quiet) {
      green = log.color.green;
      log.it("Loading: " + (green(lotus.relative(babelPath))));
    }
    babelCache[babelPath] = babel = require(babelPath);
  }
  if (!options.quiet) {
    green = log.color.green;
    log.it("Transforming: " + (green(lotus.relative(file.path))));
  }
  babelOptions = objectify({
    keys: babelKeys,
    values: options
  });
  babelOptions.filename = file.path;
  babelOptions.highlightCode = false;
  babelTransform = Promise.ify(babel.transformFile);
  return babelTransform(file.path, babelOptions).then(function(transformed) {
    var dest;
    fs.writeDir(path.dirname(file.dest));
    fs.writeFile(file.dest, transformed.code);
    file._reading = null;
    dest = lotus.File(file.dest, file.module);
    dest.lastModified = lastModified;
    return dest;
  });
};

makeIgnoreFn = function(options) {
  var ignore, only;
  ignore = steal(options, "ignore");
  only = steal(options, "only");
  return function(file) {
    if (ignore && mm.isMatch(file, ignore)) {
      return true;
    }
    if (only && !mm.isMatch(file, only)) {
      return true;
    }
    return false;
  };
};
